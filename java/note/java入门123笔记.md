### 1.5.1	类
```java
public class HelloWorld{
}
```
在 java 里这叫一个类。java语法规定，Java源程序的文件名必须与类名相同。以上源代码需保存在文件名为 HelloWorld.java 的文件中。

### 1.5.2	方法
方法是类的功能，是一段程序的载体。
```java
public static viod main(String[] args){
	System.out.println("Hello World");
}
```
java 的方法必须在类中，一个 java 方法必须属于某个类。

### 1.5.3	main() 方法：所有 Java 程序执行的起点
Java 平台会先去被执行的类中寻找叫做 main() 的方法，找到就会执行，找不到就会报错。

### 2.3.1	在 Eclipse 中创建自己的第一个项目
Eclipse 中所有的源代码都必须属于某个项目（Project）。项目是程序的源代码以及程序用到的资源文件、外部程序库、配置等的一个集合。

###	3.1 	Java 中的基本数据类型
基本数据类型是编程语言所支持的最底层的数据类型。程序中所有的数据归根究底都是由基本数据类型构成的。

###	3.1.2	基本类型介绍
值和值域（取值范围）是 Java 基本数据类型的两个最重要的属性。
Java 共有8个基本数据类型， byte 、short 、 int 、 long 、 float 、 double 、 char 、 boolean 。

- byte 类型
	值域[ -128, 127]
- short 类型
	[ -32768, 32767]
- int 类型
	[ -2147483648, 2147483647]
- char 类型
	用来表示一个字符的。用''单引号包裹。""双引号包裹的是字符串


###	3.3.1	强制类型转换
Java 强制类型转换的语法是 "(" + "目标类型" + ")" + "想要转换的值"。
"(int) doubleValue" 就是将一个double类型的变量doubleValue的值转换成 int 的值。
Java 中如果将一个浮点数强制类型转换为一个整数时，Java 是不会进行四舍五入操作的，而是直接将浮点数的小数部分全部删除。

- 当操作符的操作数有不同的精度时，Java 会将低精度的操作数转换为高精度的操作数，然后进行运算。运算的结果也是高精度的值。
- 对于直接出现在程序中的整数，Java会当作int类型处理；对于浮点数，Java会当作double处理。


### 3.3.3	强制类型转换最优先
```java
public static viod main(String[] args){
    double doubleValue = 9.9;
    int intValue = 0;
    intValue = (int)doubleValue + 0.5;
    System.out.println(intValue);	//	编译器会输出"可能损失精度"错误。
}
```

- 强制类型转换运算的优先级高于算数运算。


### 3.3.4	等号其实不简单
- 等号（=）除了会完成赋值操作以外，也跟其他运算符一样，会返回一个值。
- 在等号左边的表达式中可以使用等号右边的变量。


### 3.3.5	小心使用浮点数进行比较
> 前面介绍过，浮点数其实是不可能完全精确地表示一个小数。也就是说，判断两个浮点数是不是相等的时候，很可能得不到想要的结果。我们觉得明明是两个以为相等的浮点数，可能Java认为它们并不相等。其实在Java中，因为浮点数不精确这个特点，极少使用浮点数进行相等运算（==）。当需要判断两个浮点数是不是相等的时候，比较通常的做法是让两个浮点数相减，如果它们的差足够小，那么就认为两个浮点数是相等的。
- 注意：浮点数没有绝对的相等，只有近似的相等。Java中只有整数才有绝对的相等。



###	3.3.6	boolean和char
Java 中表示一个字符时不能够直接写一个字符，需要用一对单引号将这个字符括起来。


### 3.3.8	String——char串起的项链
在Java中，用双引号将一串字符括起来，这就创建了一个字符串。字符使用单引号。
字符串类型在Java中使用String表示的。
```java
	String sayHello = "Hello World";
```
Java中的基本数据类型是“数据原子”，所有其他类型的数据都是由基本数据类型“组装”而成的。这里，就可以认为String类型就是将一定数量的char类型变量组装起来后形成的一个新的类型。

### 3.3.9	转义符——看不见写得出
转义符都是以反斜杠（“\”）开头的，这是转义符的标志。
当Java编译器处理到一个反斜杠的时候，它就会期待后面的字符可以和反斜杠一起组成一个合法的转义符，否则将会报错。
如果想给一个字符赋值为反斜杠，或者镶在String中包含一个反斜杠字符，那么就需要使用反斜杠的转义符（“\\”）。

### 4.4.2	for语句

![for语句语法结构](D:\learn\gitRepository\java\note\assets\for.png)

- 初始化语句：初始化语句是整个for语句中首先执行的语句。它只执行一遍，一般来说它会创建一个变量，这个变量会用在后面的条件语句中。
- 条件语句：条件语句是用来判断for语句循环体是否执行的。for语句在执行完初始化语句后，就会计算条件语句的值，如果条件语句的值为true，则执行for语句的循环体，如果为false，则整个for语句执行完毕。
- 条件变化语句：这个语句是在循环体每次执行完毕后执行的语句。



### 4.6.1	continue关键字
- Java语法规定 continue 语句必须出现在代码块的最后一行。如果 continue 语句后面还有代码，编译就会出错。
- continue 关键字只能用在循环中，它的作用是结束当前的循环体代码执行，继续循环需要做的事情。



### 4.6.2	break关键字
- break关键字的语义是终止其所在的循环或语句。
- break语句结束其所在的循环，而如果有循环嵌套，则不会终止外部的循环。
- Java语法要求break语句要放在其所在代码块的最后一行。



### 4.7	使用switch进行跳转
switch语句，根据一个Int变量或者char变量的值让程序进行分支。



### 5.1.2	数组初探
数组是一组相同类型变量的集合。
```java
int studentCount = 5;	//	创建一个int变量studentCount，并给它赋值5
int[] students;	//	声明了一个int数组，数组名字为students
students = new int[5];	//	创建了一个代表“5个int变量”的数组，并赋值给students
```

上面3行代码分别创建了一个int变量和一个int数组。对于“int studentCount = 5;”我们应该很熟悉了。

下面看第2行创建数组的代码，这行代码声明了一个名为students的int数组。
先看一下声明数组的语法： “类型” + “[ ]” + “一个或多个空格” + “数组名字” 。
语法中与普通变量唯一不同的地方就是类型后面跟着一对中括号。
这对中括号就标志声明一个数组而不是创建一个普通的变量。

紧跟着第3行创建了一个数组，并将这个数组赋值给声明的 students 。
创建一个数组的语法为： new + 空格 + 类型 + [ + 一个代表数组大小的非负整数 + ]。
其中，new 就是 java 中的关键字，可以把它的意思理解为“创建，新建”。
“new int[5];”的意思就是“创建一个数组，数组中的每个元素的类型为Int,数组中包含5个元素”。

在创建数组的时候，中括号中的数字5可以被一个int变量代替，但是它的值必须是非负数。
例如，在上面的代码中，就可以将第3行代码写为“students = new int[studentCount];”。
因为studentCount的值也是5，所以它们的意义是完全一样的。

- 不要访问不存在的数组元素。访问不存在的、超出数组编辑的元素编译时是不会处处错误的，但是在程序执行到这行的时候，会发现代码实在访问一个不存在的数组元素，就会给出一个错误。
- 数组的大小一旦创建后就不可修改。所以不要去想 Java 中是否有可以扩展或者缩小一个数组容量的方法。




### 5.1.5	创建数组的简洁语法
- 创建数组的另一种语法："{" + "数组中的元素值，中间用逗号隔开" +"}"。
- 使用此语法时，必须在一个语句中完成数组的声明、创建和赋值。



### 5.3.1	什么是多维数组
创建三维数组
```java
int [][][] allStudents = new int [5][25][55];
```
- 多维数组的创建和使用与一维数组类似，需要几维就“加几对中括号”。
- 多维数组元素计算规则是各维度大小相乘。
- 使用多维数组中的元素时，在中括号内指定各个维度的下标。

```java
//	一维数组有一种使用大括号的简单创建语法，这种语法对于对维数组也是存在的。
int [][] gradeStudents = new int [2][3];
//	上面的数组创建了一个二维的int数组，第一维大小为2，第二维大小为3。
//	下面展示一下使用大括号创建一模一样的数组的代码。
int [][] gradeStudents = {{0,0,0},{0,0,0}};
```

- 多维数组的实质：多维数组是由一级级的一维数组组成的；在这个层次结构中，除了最后一层是真正的由数组元素构成的数组外，其余的数组都是数组变量的数组，且数组变量数组中的元素的维度递减。




> 对象：我们可以接受词典中“行为或思考时作为目标的人或事物”这样的解释。


### 6.1	驾驶汽车向类（class）的世界进发

### 6.1.2	类的组成

> “类”与我们之前学习的基本数据类型不同。类不是int这种原生的基本数据类型。
> 它是通过封装其他数据类型，达到创建新的数据类型的目的。
> Java要求在使用 public class 修饰一个类时，存放类的文件就必须命名为“此类的名字”+“.java”。
> Java语法还规定，在一个源文件中，必须有且只能有一个public的类。
> 提示：一个源文件（*.java文件）内的内容是“1个public的类” + “0个或者多个不是public的类”。
> Java中有很多的修饰符。访问修饰符是修饰符的一种。修饰符的作用就是给被修饰的实体赋予一个新的属性。



### 6.1.3	使用自定义的Car类
java 平台创建出类的一个实体后，会给其中的每个属性赋初始值。




### 6.1.4	类和对象
> 类是一种抽象，它把一类物体的特征抽象出来，通过适当的数据类型表示。
> 对象和类这两个概念，更多的是从其意义上理解。
> 类是定义，是抽象，是一种数据类型；对象是个例，是具体，是具体的数据。
> 对象是按照类的定义创建出来的一个实例。



### 6.1.5	源文件的存放
> Java 平台规定：对于使用public修饰的类，存放类的源代码的源文件的文件名必须是“类名”+“.java”。
> 默认情况下，类和类中使用的其他类的源文件要放在同一个目录下。
> Java 编译器会在找不到Class文件但是可以找到源文件的情况下，自动对源文件进行编译并使用产生出来的Class文件。



### 6.1.6	理解引用
> 基本数据类型是 “名” 与 “实” 一体的。对于类，Java 是采取 “名” 与 “实” 分离的方式。“实” 就是前面学过的对象，而 “名” 则是一直称呼为 “类变量“ 的东西，它就是我们将要学习的引用。声明一个类变量，就是创建一个引用。

```java
Car referenceToCarObject;
```
上面这行代码，就是创建了一个Car类的引用。这个引用有下面几层意思。
- 可以让这个引用指向一个Car类的对象。
- 它不是Car类的对象，但是可以让它代指一个Car类的对象。因为对象是没有名字的，只是一个实体，所以指向一个对象的引用就是那个对象的一个名字（可以让多个引用指向一个对象）。
- 可以使用它操作它指向的Car类的对象。
- 类不同于基本数据类型。要使用new关键字创建一个类的对象，然后使用一个引用指向创建的对象。
- 引用指向对象所属的类必须和引用的类型匹配。



### 6.1.7	null关键字
> Java 中，引用的初始值是使用关键字null描述的。null这个单词在英语中的意思就是“空，零，无效的”。
> 如果不确定一个引用的值是不是null，那么使用之前先把引用的值与null进行一下比较是个好的习惯。	



### 6.2.2	定义自己的引用
- 可以在类中声明一个自己类型的引用。
- 给这个引用赋值的时候，需要注意避免死循环。



### 6.2.4	类的数组
- 类的数组其实是类的引用的数组。
- 创建类的数组的对象时，不会创建类的对象。



### 7.1.2	那么，方法到底是什么呢？
- 方法是类的功能。类的功能只能通过方法来体现。
- 方法必须是某个类的，即方法必须定义在类中。



### 7.1.3	方法调用过程初探
> Java 的普通方法是可以操作调用它的对象的属性。



### 7.2	Java普通方法的组成部分
```java
public void driveCar (int a,double b){
    //...
}
```
访问控制符 返回值类型 方法名 （方法参数列表）｛
//方法体
｝
> 方法的访问控制符是用来控制方法的访问权限的。
> void 关键字：定义一个方法的返回值是空。
> 如果一个普通的Java方法没有返回值，则要使用void标记，而不能什么都不写。
> Java 方法只能返回一个值，或者使用 void 关键字指定一个方法不返回任何值。



### 7.3.2	带参数的方法有何不同？
- 带参数方法名后面有定义了调用此方法所需要提供的参数。
- 对于带参数的方法，在其方法体内不但可以使用类中定义的属性，还可以使用参数列表中的参数。




### 7.4.4	使用return结束方法
> 说到这里，有必要养成一个习惯：在使用一个参数的时候，首先检查其合理性。（如给骑车加速需先判断速度是否为正数。）




### 7.5	方法重载（overload）给汽车加速添加个限制
> 方法的重载是在同一个类中，方法与方法之间的关系



### 7.5.1	什么是方法的签名
> Java 平台就是靠方法的签名来区分方法的。



| 方法名 | 方法签名 |
| --- | --- |
| driverCar | driveCar() |
| setSpeedAndDirction | setSpeedAndDirction(int,String) |
| isOverSpeed | isOverSpeed() |
| raiseSpeed | raiseSpeed(int) |


> Java平台不仅仅是靠方法名字来区分方法的，还要看方法的参数类型。方法签名相同的方法是不可以在同一个类中同时存在的。
> 

- 方法签名是 Java 平台执行方法的时候，用来确定执行哪个方法的。
- 方法签名是由方法名和参数类型决定的，与方法的其他属性无关。



### 7.5.2	什么是重载？为什么要重载
> 类中的两个或者多个方法，如果它们有相同的方法名，但是却有不同的方法签名，那么这几个方法就是重载的。重载不是一个方法的事情，而是两个或者多个方法在一起体现出来的特性。

- 重载是指在一个类中，有两个或多个方法，它们有一样的方法名，但是却有不一样的方法签名。
- 重载的优势是可以重用方法名。



### 7.5.5	重载容易引发误解的两个地方——返回类型和形参名
- 方法的签名与方法的返回值无关。
- 方法的签名与方法的形参名字无关。



### 7.5.6	重载中的最难点——参数匹配原则
> Java 在遇到这类问题时，总会选择一个赋值规则的精度最小的类型来使用。赋值规则就是低精度的数值可以赋值给高精度或者同精度的变量；而高精度的值却不能赋值给低精度的变量。
> 基本类型中与精度有关的类型，精度从小到大排列依次是：byte、short、int、long、float、double。所以，现在我们的实参是一个int值，按照赋值规则，它既可以选择赋值给一个int变量，也可以选择赋值给一个double变量。两个候选都没有被淘汰掉。不怕，还有第2个规则——精度最小。
> 重载中参数类型匹配的原则：第一要复合赋值规则，即低精度的值可以赋值给高精度或者同精度的变量，而高精度的值却不能赋值给低精度的变量；第二即精度最小。



### 7.7.1	什么是局部变量
- 局部变量是指方法中声明的变量。
- 局部变量的作用域从声明开始，到方法体结束。
- 在读取一个局部变量之前，必须要给这个局部变量赋值。



### 7.7.2	什么是实例变量
- 实例变量是定义在类里面的变量，与方法平级。
- 实例变量的定义需要3部分：访问控制符 + 数据类型 + 变量名
- 实例变量可以有访问控制符。
- 实例变量具有初始值，使用时不必关心是否已经赋值。


### 7.8.1	发现问题：当实例变量和局部变量重名
- 方法中使用到的变量的寻找规律是先找局部变量，再找实例变量，如果没有找到，将会有一个编译错误而无法通过编译。



### 7.8.2	经常深藏不露的this关键字
> this 关键字是在方法中使用，是指向对象自己的引用。
> 在一个方法内，如果没有出现局部变量和实例变量重名的情况下，是否使用 this 关键字是没有区别的。this 关键字经常是深藏不露，只有在出现局部变量和实例变量重名的情况下，才会有使用 this 变量的必要。
- this关键字只能在方法中使用，是用来指代调用方法的类的对象的。
- 如果使用 this 关键字访问一个变量，则是访问实例变量而非局部变量。



### 7.8.3	在方法中调用方法
- 在方法中调用方法是 Java 中很常用的。
- 在同一个类中，Java 普通方法的互相调用可以省略 this+点号，而直接使用方法名 + 参数。因为 Java 编译器会帮我们加上。



### 7.9	构造方法
> 和普通的 java 方法相比，构造方法有两点特殊：构造方法没有返回值；构造方法的方法名必须与类名一样。除此之外，构造方法也有访问控制符，也有参数列表，也有方法体。
- 构造方法没有返回值类型（不能用void），但是构造方法内可以使用return。
- 构造方法名必须与类名一样。
- 只有同时具备以上两个条件，一个方法才是一个构造方法。



### 7.9.2	如何使用构造方法
> Java 语法规定，一个类可以有多个构造方法，至少要有一个构造方法。Java 编译器在一个类没有任何构造方法时，他会给没有构造方法的类增加一个默认的，什么都不做的构造方法，所以我们的类才能够通过编译。
> 构造方法也可以重载。
> 第6章中我们知道，new Car() 会创建一个Car 类的对象，其实还漏掉了一点，它不仅仅是创建了一个对象，它还在创建对象后，调用了相应的构造方法。
> 现在，我们清楚了创建一个对象的过程。
> 1）在遇到new关键字的时候，Java 平台会创建出这个new后面紧跟着的类的一个对象。
> 2）然后，Java平台会去根据紧跟在类后面的参数列表去调用相应的构造方法。之所以仅根据参数列表就可以调用构造方法，是因为构造方法的名字是确定的，只能是类的名字。
> 构造方法本身并不神秘，通常它只是去完成一些初始化的工作。构造方法本身并不能创建出一个对象，真正创建对象的是Java平台，构造方法只是Java平台在创建出一个对象之后会默认调用的一个方法，仅此而已。




### 7.9.3	留个无参数的构造方法——给重要属性赋初始值
> 我们发现有两个String的构造方法挺好用的，看那个空的构造方法是个累赘。好，现在尝试把它删除，看看会发生什么。删除了那个无参数的Car构造方法后并保存，我们惊奇地发现：在Eclipse的Package Explorer视图中很多测试类都有了一个红叉！为什么呢？因为我们之前的测试程序都是使用new Car()  来创建一个对象的，这个时候 Java 平台自然会在创建一个Car的对象后去调用无参数的构造方法，刚才把它删除了，所以才会导致很多测试类出错。
> 等一下，Java编译器不是会给我们增加一个无参数的、什么都不做的构造方法吗？事实上是，Java编译器只会在一个类没有任何构造方法的时候，才会给类添加一个那样的构造方法。而此时，我们的Car类已经有了由两个String做参数的构造方法了，所以Java编译器就不会再给Car类添加构造方法了。这时候，Car类的无参数的构造方法被我们删除了，所以很多测试类才会出错。
> 空的构造方法的好处就是使用方便，使用者无需在创建对象的时候传递参数。有个空的构造方法，并且在方法中给重要的属性赋初始值是个好习惯。

- Java编译器在编译一个类的时候，只会在那个类没有任何构造方法的时候，才会给一个类添加一个空的、什么都不做的构造方法。
- 给类留个无参数的构造方法，并在这个方法中对重要属性赋初始值是个好习惯。这样可以让类更容易地被使用，并减少程序出错的概率。



###	7.9.4	在构造方法中调用构造方法
Java语言支持在一个构造方法中调用另一个构造方法。
``` java
//	构造方法，用来给name和color属性赋初始值
public Car(){
    this("java护航者","咖啡豆色");
}
```
> 我们发现，在这个构造方法的第一行也是唯一一行，this关键字的使用很奇怪，直接就是this关键字后面加实参。没什么好解释的，这就是Java语法。那么它会在Car类中搜索符合要求的构造方法，然后去执行那个构造方法，其过程，包括寻找方法，实参形参赋值、方法调用后的返回等，都是与普通的方法调用一样的。
> 关于这个语法，需要注意的一点是：如果要通过this+参数列表调用别的构造方法，那么这行程序必须在第一行。

- 通过 this+构造方法实参，可以在一个构造方法中调用同类的另一个构造方法。
- 通过 this+构造方法实参调用同类中另一个构造方法的时候，必须将这个放在构造方法的第一行。



### 7.10.2	使用例程将本章的知识穿起来
> 使用一个方法来给属性赋值而不是直接赋值是一个好习惯。例如setSpeed()方法，也可以直接通过myCar.speed = newSpeed;来设置车速，但是这样就没有对newSpeed的合理性进行判断，如果newSpeed的值小于0，myCar的speed属性值也将小于0，而如果使用setSpeed()方法则不会发生这种情况，因为setSpeed()方法将会对参数进行判断，然后在参数不小于0的情况下才会将值赋给speed属性。




###	7.11	小结：多方位理解Java方法

1. 单个方法是处理数据的代码块
> 其实撇开现实中对应的物体，还可以将java方法理解为对数据的处理。其实从另一个角度来看，程序的核心功能就是处理数据。

2. 方法是用来重用的
> 其实，方法调用就是在调用方法的地方重用被调用方法体的代码。所以，同样地，当我们自己写程序的时候，如果发现某些处理过程是相似的，就可以将这个过程抽象成一个方法。

3. 将方法组织起来，就是一个系统



###	8.1.1	Java中的包
> 为了将源文件更好地组织起来，Java中的类可以存放到不同的文件夹中。Java中用于存放源文件的文件夹叫做包（package）。
- java中的包名必须是一个合法的标识符。
- 包的全限定名是从源代码的根目录开始，以点好"."作为分隔符的。



###	8.1.2	在Eclipse中使用包
> 其中src目录就是我们所说的“源代码的根目录”。



###	8.1.3	天上掉下个Package
> Java要求类需要在源代码的第一行使用package语句标记出其所在的包，如果标记与类实际所在的包不符，java编译器将会给出一个错误。

package语句的格式如下：
package + 空格 + 类所在的包的全限定名 + ；
- package语句用来标识类所在的包。这个必须与源文件实际所在的包一样，否则Eclipse将会给出一个错误。
- package语句的格式是：package + 空格 + 类所在的包的全限定名 + ；。



###	8.1.4	包带来了什么？
> 全限定名仅仅与类相关，用于告诉Java编译器程序中使用的到底是哪一个类。
- 不同的包中可以有同名的类。
- 类的全限定名是：类所在的包的全限定名字 + . + 类名。
- 使用包中的类时都是要使用类的全限定名，包括创建类的引用和创建类的对象的。使用类的引用则与全限定名没有任何关系。
- 对于在同一个包中的类，可以省略类全限定名中的包名。
- 当编译包中的类时，需要进入源代码的根目录，然后根据类源文件的路劲和源文件名进行编译，否则Java编译器将会找不到其中用到的其他包中的类。



###	8.2.1	import语句
> import是java中的关键字，用于提供给Java编译器“类中使用到的其他类的寻找位置”。

import 语法
import + 空格 + 类全限定名 + ；
> 它的作用是：在java编译器编译类的时候，当遇到类中使用到了一个没有包含全限定名的类时，会先去import语句中寻找被预先“引入”的类。如果找得到，java编译器则会认为那个没有使用全限定类名的类就是import语句中引入的类。

- import语句的一种使用语法是：import + 空格 + 类全限定名 + ；
- 在源代码中通过使用import语句预先引入的类的全限定名，可以在使用这些类直接使用类名而无须使用类的全限定名。
- 源文件中的import语句可以有多个。




###	8.2.2	一网打尽包中所有类
> Java中的package语句还有另一种类似的语法，可以用来将一个包中所有的类一起引入进来。这样，当使用到一个包中的多个类时，就不必一个个地输入import语句了。这种语法的格式如下：
> import + 空格 + 包的全限定名 + . + * + ;
> import语句的两种语法可以在类中同时使用。
> 注意：此语法仅仅是用来引入包中的所有类，对于此包中的子包中的类则没有引入。




###	8.2.3	import语句带来的小问题
- Java编译器不允许在同一个源文件中存在两个或者多个，使用第一种语法的import语句引入类名相同的类。
- 如果第一种语法的import语句引入的类和第二种import语句引入的类有冲突，Java编译器会采用第一种import语法结构引入的类。




###	8.2.4	默认引入的包
> Java编译器会默认引入 java.lang 包中的所有类。




###	8.5	小结：包让Java的类更清晰优雅
- 一个Java项目中的源代码都是存放在某个目录下的，这个目录叫做源代码的根目录（Eclipse中的src目录）。
- Java中的包是用来给源文件分门别类的，包名必须是合法的标识符名。Java中源代码的包在磁盘上就是一个目录。
- 包的全限定名是从源代码根目录开始的。包名与包名之间使用点号隔开。
- Java的包中可以包含源文件，也可以包含子包。
- package语句的语法。
- 如果一个源文件不是在default package中，那么此源文件的第一有效行必须是能够正确表示该源文件所在包的package语句。
- package语句的语法是：package + 空格 + 类所在的包的全限定名 + ；
- 类的全限定名可以唯一地确定一个类。它的格式是：类所在的包的全限定名 + . + 类名。
- import语句是用来引入其他类的。它有两种语法格式，分别可以引入一个类和一个包中的所有类（不包过子包中的类）
- 当在类的源代码中使用了其他类，而这个类却没有使用全限定名，那么Java编译器会按照如下规则寻找这个类：使用第一种import语句引入的类；与这个类在同一个包中的类和使用第二种import语法引入的类。如果通过这两种途径都没有找到需要用的类，那么Java编译器会抛出错误。
- Java编译器会默认引入java.lang中的所有类。这个包中的类是非常常用的基础类。



###	9.1.1	得到数组的长度
- 数组对象的length属性代表了数组中元素的个数。



###	9.1.2	加餐：不可改变的final变量
> 数组对象一旦创建出来以后，其中包含的元素的个数是不能够增减的。
> 如果想要一个变量拥有这种特性，那么就需要用到Java中的一个关键字——final来修饰这个变量。
> final修饰的变量必须赋初始值、
> final关键字可以用来修饰成员变量和局部变量。对于使用final关键字修饰的变量，java有如下两个语法要求。
> 使用final关键字修饰的变量，必须在创建/声明的时候赋初始值，且这个初始值必须是确定的值
> 使用final关键字修饰的变量，在赋初始值之后不能再次赋值




###	9.1.6	多维数组的clone()方法
- 数组元素类型为类时，调用数组对象的clone()方法，赋值的是数组的内容，也就是引用，而并没有赋值引用指向的对象。




###	9.2.1	遍历String中的字符
> String类实际上是用来表示0个或者多个字符的类。
> int length():这个方法的返回值是字符串的长度，也就是字符串中包含的字符的个数。
> char charAt(int index):这个方法返回指定位置的字符。它的参数就是想要得到的字符所在的位置，而返回值就是处于此位置的字符。
> 使用 == 操作符来判断两个char变量是否相等。



###	9.2.2	获取字符串中的一部分
> 有时我们需要截取一个String对象的一部分。String类提供了现成的方法来完成这个功能，这个方法叫做substring，它有两个重载。
- String substring(int beginIndex,int endIndex):其作用就是创建一个新的字符串，它的内容是原字符串中从第beginIndex个字符到第endIndex（不包括此字符）为止的内容。
- String substring(int beginIndex):它是上一个方法的重载，作用是创建一个新的字符串，它的内容是原字符串中从第beginIndex个字符开始直到最后的所有内容。



###	9.2.3	判断两个字符串是否相等
> 其实对于对象来说没有基本类型变量那样明确的相等或不相等的概念。
> String类的equals()方法会比较两个字符串中的每个字符，如果完全相等，则返回true，否则返回false。
> 使用 == 运算符可以判断两个引用是否指向同一个对象。



###	9.2.5	分割字符串
> String类提供一个split()方法，它可以将一个字符串以另一个字符串为分隔符将字符串分割为1到多个字符串对象，它的返回值就是这些字符串对象的数组。



###	9.2.6	在字符串中查找子字符串或字符
- int indexOf(char ch):此方法返回字符ch在字符串中首次出现的索引值，如果字符没有在字符串中出现，则返回值为-1。
- String endsWith(suffix):这个方法的作用与上一个方法类似，用来返回一个字符串中另一个字符串首次出现的索引值，如果没有则返回-1。




###	9.2.7	替换字符串中的内容
- String replace(char oldChar,char newChar):此方法会创建一个新的字符串作为返回值，新字符串中的oldChar将被替换为newChar。
- String replace(charSequence target,CharSequence replacement):此方法会创建一个新的字符串作为返回值，新字符串中的target将被替换为replacement。



###	9.2.8	String对象——磐石刻字
> String对象的内容是不可改变的。也就是说，String对象在创建出来以后，其中的内容就不可改变了。



###	9.3	String类的最佳拍档——StringBuffer类
> 为了解决String对象内容不可改变带来的不便，Java类库提供了另一个类——String Buffer。它的内容可以随意改变。StringBuffer类的方法专注于对字符进行拼接、插入、删除、替换和反转等操作，并且可以方便地将StringBuffer对象中包含的字符串转换为一个String对象。



###	9.3.1	StringBuffer：专业操纵字符
> StringBuffer中最常用的方法append()方法，它有很多重载方法，可以把基本数据类型变量、字符串、字符数组等内容拼接到自己内容的尾部。
> 使用StringBuffer生成想要的内容，然后将内容转换为String对象使用是一种典型的做法，也是为什么StringBuffer和String是一对“最佳拍档”。



###	9.4	最熟悉的陌生人：main()方法
> 现在我们只知道main()方法是Java程序的入口，因为Java平台总会在类中寻找main()方法，然后通过调用它来启动整个程序。



###	9.4.1	main()方法的参数
> main()方法一直都有个String数组的args参数。在命令行中，只要在类名后面写上想要的字符就可以了。Java系统会将类名后面的字符串以空格为分隔符分割成一个String数组，然后传递给main()方法，这样就可以在main()方法中使用这个字符串数组了。




###	9.4.2	static关键字
> static关键字可以用来修饰方法和变量。
> static + 变量类型 + 变量名
- 在类中，使用static关键字修饰变量叫做类变量或者静态变量。
- 如果没有给类变量赋值，Java会根据类变量的类型给它赋初始值。
- 关于类变量最重要的一点：类变量是类范围内中的一个属性。创建对象的时候，不会创建类变量。类变量可以通过类名直接访问。



###	9.4.3	当方法遇到static关键字
- 和使用static修饰的变量一样。static修饰的方法可以通过类名直接调用。
- 类方法中的不能够使用this关键字。因为this关键字代表对象，而类方法是类范围内的方法，所以代码内不能使用this关键字去访问变量和方法。
- 类方法内部可以调用类方法和使用类变量。
- 没事使用static修饰的方法可以调用使用static修饰的方法。
> 使用static修饰方法时，static关键字要放在方法的访问控制符和返回类型之间。其余与普通方法一样。
> static方法的语法如下：
> 方法的访问控制符（public）+ static + 返回值类型 + 方法名 + （方法参数） + 方法体




###	9.5	小结：学会使用类中的方法
- 引用的 == 操作的意义：判断两个引用是否指向同一个对象。
- final关键字用来修饰变量，该变量必须且只能在声明/创建的时候赋予它初始值。以后不允许再给该变量赋值或修改值。
- 数组的clone()方法的执行意义：复制一份数组的内容。
- String对象数据不可变。
- 理解static关键字、类方法和类变量。



###	10	继承和多态
> 继承和多态是一门面向对象的编程语言必须具有的核心功能。



###	10.1.1	饭前水果：实例变量的访问控制符
- 访问控制符也可以用来修饰实例变量，以控制实例变量的可访问范围。
- 局部变量不能使用访问控制符修饰。



###	10.1.5	使用继承——问题迎刃而解
> 代码class Bus extends CarBase的意思就是“类Bus是从类CarBase继承而来的。”称Bus类为子类，称CarBase类为父类或基类。继承的作用就是让子类继承父类中的方法和属性。
> 对于类方法和类属性，子类同样也将它们继承了过来。
> 继承绝不是简单地“直接共享”父类中“所有的”方法和属性。子类中能够使用父类中哪些属性和方法，在语法上有着严格的规范的。这个规范主要和访问控制符有关。
> 继承的语法格式如下：
> 子类类名 + extends + 父类类名




###	10.1.9	万类之祖——Object类
> java.lang包，这个包中的类都可以视为是构成java语言的基础类。在这些类中，地位最重要的莫过于Object类，因为Object类是所有除了自己之外的类的父类。




###	10.2.1	父随子行
> 实际上，“java在创建一个子类的对象的同时，也创建了其父类的一个对象”。没错，这句话是事实。为什么子类中会包含父类的属性呢？可以这么理解——子类对象在创建的同时会创建一个其父类的对象，而这个对象是隐含（或者说是内嵌）在子类中的。当我们通过子类的引用使用其父类的属性时，其实可以理解为是访问这个内嵌的父类对象的属性。




###	10.2.2	当构造方法遇到继承
> 子类中唯一没有直接继承下来的就是父类的构造方法。




































